# Import flask and datetime module for showing date and time
from flask import Flask, jsonify
import requests
import random

from api.promptlayer.routes import bp_promptlayer
from api.openai.routes import bp_openai, completion_create

# Initializing flask app
app = Flask(__name__)
 
app.register_blueprint(bp_promptlayer)
app.register_blueprint(bp_openai)

URL_POKEAPI = "https://pokeapi.co/api/v2"

@app.route('/generate_battle')
def generate_battle():
    pokemon1_id = random.randint(1, 150) # range pokemon (1, 150)
    pokemon2_id = random.randint(1, 150)
    return jsonify({"pokemon1_id": pokemon1_id, "pokemon2_id": pokemon2_id})

def analyze_battle(winner, loser):

    p_name1 = winner['name']
    p_name2 = loser['name']

    max_characters = 255

    prompt = f"""
    You are about to witness an exciting Pokémon battle between {p_name1} e {p_name2}! 
    Let's take a detailed look at each Pokémon's attributes, types, and moves to understand how the winner was decided.

    {p_name1} It's a Pokémon of the type {winner['types'][0]['type']['name']} com 
    {winner['base_experience']} base experience points. Its stats are as follows:
    - Statistic: {winner['stats'][0]['base_stat']}
    - And other relevant attributes.

    {p_name2} It's a Pokémon of the type {loser['types'][0]['type']['name']} com 
    {loser['base_experience']} base experience points. Its stats are as follows:
    - - Statistic: {loser['stats'][0]['base_stat']}
    - And other relevant attributes.

    Now, let's look at each Pokémon's moves and how they fared in battle. 
    (Add information about the moves used and their effects)

    (Add details about the advantages and disadvantages of Pokémon types and how this influenced the battle)

    After an intense battle, {p_name1} emerged as the winner! His combination of attributes and well-planned strategy gave him victory over {p_name2}. 
    Congratulations to the trainer of the winning Pokémon on his brilliant victory!
    Summarize in a maximum of {max_characters} characters
    """

    # Get the response generated by the model
    return completion_create(prompt, pl_tags=[
        'batalha', 
        f'winner:{p_name1}', 
        f'loser:{p_name2}'])

@app.route('/battle_result/<int:pokemon1_id>/<int:pokemon2_id>')
def battle_result(pokemon1_id, pokemon2_id):

    # Uses PokeAPI to get information about Pokémon using IDs.
    r = requests.get(f"{URL_POKEAPI}/pokemon/{pokemon1_id}/")
    pokemon1 = r.json()

    r = requests.get(f"{URL_POKEAPI}/pokemon/{pokemon2_id}/")
    pokemon2 = r.json()

    # Determine the winner based on the characteristics (base_experience) of the Pokémon.
    # Can be improved with other factors like types, stats

    winner = pokemon1
    loser = pokemon2

    if pokemon2['base_experience'] > pokemon1['base_experience']:
        winner = pokemon2
        loser = pokemon1


    # openai
    explanation = analyze_battle(winner, loser)

    return jsonify({"winner": winner['name'], "explanation": explanation})

    # explanation = f"A base_experience do {winner['name']} é \
    #     {winner['base_experience']} \
    #     enquanto do {loser['name']} é {loser['base_experience']}"

# Running app
if __name__ == '__main__':
    app.run(debug=True)
